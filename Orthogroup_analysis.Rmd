---
title: "Orthogroup_analysis"
output: html_document
date: "2026-01-05"
---

```{r, Orthogroups}

library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(purrr)

ortho <- as.data.frame(read.delim("/Users/jyeam/Documents/Genomes/Galaxy/Hierarchical_orthogroups.tsv", header = TRUE))
names(ortho)[4] <- "pungens"
names(ortho)[5] <- "quiescens"
names(ortho)[6] <- "umbonatus"
ortho

annotate_species <- function(ortho_df, species_col, anno_df, id_col = "TranscriptID", prefix = species_col) {
  stopifnot(species_col %in% names(ortho_df))
  stopifnot(id_col %in% names(anno_df))
  anno_cols <- setdiff(names(anno_df), id_col)
  expanded <- ortho_df %>%
    select(OG, all_of(species_col)) %>%
    mutate(across(all_of(species_col), as.character),
           across(all_of(species_col), ~na_if(.x, "")),
           across(all_of(species_col), ~str_replace_all(.x, "\\s+", ""))) %>%
    separate_rows(!!sym(species_col), sep = ",") %>%
    filter(!is.na(!!sym(species_col))) %>%
    rename(!!id_col := !!sym(species_col))

  # join annotations for this species
  joined <- expanded %>%
    left_join(anno_df, by = id_col)

  # collapse back to one row per OG, prefixing columns
  collapsed <- joined %>%
    group_by(OG) %>%
    summarise(
      !!paste0(prefix, "_TranscriptIDs") := paste(unique(.data[[id_col]]), collapse = "; "),
      across(all_of(anno_cols),
             ~ paste(unique(na.omit(.x)), collapse = "; "),
             .names = paste0(prefix, "_{.col}")),
      .groups = "drop"
    )

  collapsed
}

pun_block <- annotate_species(ortho, "pungens",   annotations_pun_df, id_col = "TranscriptID", prefix = "pungens")
qui_block <- annotate_species(ortho, "quiescens", annotations_qui_df, id_col = "TranscriptID", prefix = "quiescens")
umb_block <- annotate_species(ortho, "umbonatus", annotations_umbo_df, id_col = "TranscriptID", prefix = "umbonatus")

# Join them all back to the orthogroups table
ortho_annotated <- list(ortho, pun_block, qui_block, umb_block) %>%
  reduce(left_join, by = "OG")
keep <- !grepl("^(pungens|quiescens|umbonatus)_(TranscriptIDs?|GeneID|Contig|Feature|start|stop|end)$",
               names(ortho_annotated), ignore.case = TRUE)
ortho_annotated <- ortho_annotated[, keep] ######################## THIS IS IT #####################################
write_csv(ortho_annotated, "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/R/ortho_annotated.csv")

make_map <- function(ortho, species_col, species_name) {
  ortho %>%
    select(OG, all_of(species_col)) %>%
    mutate(across(all_of(species_col), as.character)) %>%
    mutate(!!species_col := na_if(.data[[species_col]], "")) %>%
    separate_rows(!!sym(species_col), sep = ",\\s*") %>%
    filter(!is.na(.data[[species_col]])) %>%
    rename(GENEID = !!sym(species_col)) %>%
    mutate(species = species_name)
}

map_pun <- make_map(ortho_annotated, "pungens",   "pungens")
map_qui <- make_map(ortho_annotated, "quiescens", "quiescens")
map_umb <- make_map(ortho_annotated, "umbonatus", "umbonatus")

norm_id <- function(x){
  x %>%
    as.character() %>%
    str_trim() %>%
    str_replace("\\.\\d+$","") %>%        # drop version suffix: .1, .2
    str_replace("-RA$","") %>%            # drop isoform tag examples
    str_replace("-T\\d+$","")             # drop transcript numeric tails if present
}

prep_map <- function(map_df, og_col = "OG", id_col = "GENEID", add_species = NULL){
  out <- map_df
  if (!("OG" %in% names(out)) && og_col %in% names(out))
    out <- dplyr::rename(out, OG = !!og_col)
  out[[id_col]] <- norm_id(out[[id_col]])
  if (!is.null(add_species) && !("species" %in% names(out)))
    out <- mutate(out, species = add_species)
  out
}

map_pun2 <- prep_map(map_pun,  og_col = "OG", id_col="GENEID", add_species = "pungens")
map_qui2 <- prep_map(map_qui,  og_col = "OG", id_col="GENEID", add_species = "quiescens")
map_umb2 <- prep_map(map_umb,  og_col = "OG", id_col="GENEID", add_species = "umbonatus")

one_species_genelevel <- function(dds, map_df, species, contrast_factor, lvl_A, lvl_B, use_species_in_join = TRUE){
  res <- results(dds, contrast = c(contrast_factor, lvl_A, lvl_B)) %>%
    as.data.frame() %>%
    rownames_to_column("GENEID") %>%
    mutate(GENEID = norm_id(GENEID),
           species = species)

  if (use_species_in_join && "species" %in% names(map_df)) {
    out <- res %>% left_join(map_df %>% select(OG, GENEID, species), by = c("GENEID","species"))
  } else {
    out <- res %>% left_join(map_df %>% select(OG, GENEID), by = "GENEID")
  }
  out
}

#res for each individual species with assigned orthogroup
res_pun_gene <- one_species_genelevel(dds_pungens,   map_pun2, "pungens",   contrast_factor="wp", lvl_A="high", lvl_B="low")
res_qui_gene <- one_species_genelevel(dds_quiescens, map_qui2, "quiescens", contrast_factor="wp", lvl_A="high", lvl_B="low")
res_umb_gene <- one_species_genelevel(dds_umbonatus, map_umb2, "umbonatus", contrast_factor="wp", lvl_A="high", lvl_B="low")

res_gene_all <- dplyr::bind_rows(res_pun_gene, res_qui_gene, res_umb_gene)

res_gene_all <- res_gene_all %>% filter(!is.na(OG))

# collapse to one entry per (OG, species)
res_gene_top <- res_gene_all %>%
  group_by(OG, species) %>%
  slice_min(padj, n = 1, with_ties = FALSE) %>%
  ungroup()

og_wide <- res_gene_top %>%
  select(OG, species, log2FoldChange, padj, baseMean) %>%
  pivot_wider(
    names_from  = species,
    values_from = c(log2FoldChange, padj, baseMean),
    names_sep   = "."
  )

og_wide_annot <- og_wide %>%
  left_join(
    ortho_annotated %>%
      select(OG,
             starts_with("pungens_"),
             starts_with("quiescens_"),
             starts_with("umbonatus_")),
    by = "OG"
  )

sig_thresh <- 0.01

og_calls <- og_wide_annot %>%
  mutate(
    pun_sig  = ifelse(padj.pungens  < sig_thresh, sign(log2FoldChange.pungens), 0),
    qui_sig  = ifelse(padj.quiescens< sig_thresh, sign(log2FoldChange.quiescens), 0),
    umb_sig  = ifelse(padj.umbonatus< sig_thresh, sign(log2FoldChange.umbonatus), 0),
    n_sig    = (pun_sig!=0) + (qui_sig!=0) + (umb_sig!=0),
    # simple concordance label
    concordance = case_when(
      n_sig <= 1 ~ "≤1 species sig",
      pun_sig==qui_sig & qui_sig==umb_sig & pun_sig!=0 ~ "all 3 same direction",
      (pun_sig==qui_sig & pun_sig!=0 & umb_sig==0) |
      (pun_sig==umb_sig & pun_sig!=0 & qui_sig==0) |
      (qui_sig==umb_sig & qui_sig!=0 & pun_sig==0) ~ "2 species same dir",
      TRUE ~ "discordant"
    )
  )

ogs_in_all3 <- res_gene_all %>%
  distinct(OG, species) %>%
  count(OG) %>%
  filter(n == 3) %>%
  pull(OG)

og_all3 <- og_calls %>% filter(OG %in% ogs_in_all3)
write_csv(og_all3, "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/R/Orthogroups_conserved3species.csv")

og_calls %>%
  count(concordance) %>%
  ggplot(aes(concordance, n)) +
  geom_col() + coord_flip() +
  labs(x=NULL, y="Orthogroups", title="DE concordance across species")

res_gene_top %>%
  filter(species=="pungens") %>%
  ggplot(aes(log2FoldChange, -log10(padj))) +
  geom_point(alpha=0.6) +
  geom_vline(xintercept=c(-1,1), linetype=2) +
  geom_hline(yintercept=-log10(0.05), linetype=2) +
  labs(title="pungens")

res_gene_top_noNA <- res_gene_top[complete.cases(res_gene_top), ]

```

```{r, creating files with sample labels and OG info}
suppressPackageStartupMessages({
  library(DESeq2)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(readr)
  library(tibble)
  library(purrr)
})
orthogroups_tsv <- "/Users/jyeam/Documents/Genomes/Galaxy/Hierarchical_orthogroups.tsv"  # has OG + species columns
phenotypes_csv  <- "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/Stress_Tolerance/R/sample_phenotypes_df.csv"  
conserved_csv   <- "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/Stress_Tolerance/R/Orthogroups_conserved3species.csv"  # has OG column

dds_files <- list(
  pungens   = "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/results/deseq2/dds_pungens.rds",
  quiescens = "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/results/deseq2/dds_quiescens.rds",
  umbonatus = "/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/results/deseq2/dds_umbonatus.rds"
)

# ----------------------------
# Helpers
# ----------------------------
norm_id <- function(x){
  x %>%
    as.character() %>%
    str_trim() %>%
    str_replace("\\.\\d+$","") %>%
    str_replace("-RA$","") %>%
    str_replace("-T\\d+$","")
}

make_map <- function(ortho, species_col, species_name) {
  ortho %>%
    select(OG, all_of(species_col)) %>%
    mutate(across(all_of(species_col), as.character),
           across(all_of(species_col), ~na_if(.x, "")),
           across(all_of(species_col), ~str_replace_all(.x, "\\s+", ""))) %>%
    separate_rows(!!sym(species_col), sep = ",") %>%
    filter(!is.na(!!sym(species_col))) %>%
    transmute(
      OG      = as.character(OG),
      GENEID  = norm_id(!!sym(species_col)),
      map_species = species_name
    ) %>%
    distinct()
}

# Aggregate gene counts -> OG counts, then attach phenotype-derived species label
agg_counts_by_og_with_pheno <- function(dds, map_df, map_species,
                                        pheno_df,
                                        pheno_id_col = "Admera_ID",   # change to "CustomerID" if needed
                                        pheno_species_col = "Species",
                                        og_keep = NULL,
                                        normalized = FALSE,
                                        expressed_threshold = 0) {

  # gene-level counts
  cts <- counts(dds, normalized = normalized)
  rownames(cts) <- norm_id(rownames(cts))

  # mapping gene -> OG for this mapping species
  map_sub <- map_df %>%
    filter(map_species == !!map_species) %>%
    distinct(GENEID, OG)

  gene2og <- setNames(map_sub$OG, map_sub$GENEID)
  grp <- unname(gene2og[rownames(cts)])

  keep_rows <- !is.na(grp)
  cts2 <- cts[keep_rows, , drop = FALSE]
  grp2 <- grp[keep_rows]

  # sum gene counts within OG
  og_counts <- rowsum(cts2, group = grp2, reorder = FALSE)
  og_counts <- as.data.frame(og_counts) %>% rownames_to_column("OG")

  if (!is.null(og_keep)) og_counts <- og_counts %>% filter(OG %in% og_keep)

  value_col <- if (normalized) "norm_count" else "count"

  long <- og_counts %>%
    pivot_longer(-OG, names_to = "sample", values_to = value_col) %>%
    mutate(expressed = .data[[value_col]] > expressed_threshold)

  # Attach phenotype info (including north/south pungens)
  ph <- pheno_df %>%
    mutate(sample = as.character(.data[[pheno_id_col]])) %>%
    select(sample, all_of(pheno_species_col), everything())

  out <- long %>%
    left_join(ph, by = "sample") %>%
    mutate(
      # species_out = phenotype species label (north pungens / south pungens / etc)
      species = .data[[pheno_species_col]],
      # keep original mapping species too (so you can debug later)
      map_species = map_species
    )

  # Optional sanity check: how many samples failed to match phenotype
  n_unmatched <- out %>% distinct(sample, species) %>% filter(is.na(species)) %>% nrow()
  if (n_unmatched > 0) {
    warning(sprintf(
      "WARNING: %d samples did not match phenotype table via %s. Their species is NA. Check whether dds colnames match Admera_ID vs CustomerID.",
      n_unmatched, pheno_id_col
    ))
  }

  out
}

# ----------------------------
# Read inputs
# ----------------------------
ortho <- read_tsv(orthogroups_tsv, show_col_types = FALSE)
names(ortho)[4:6] <- c("pungens", "quiescens", "umbonatus")
stopifnot(all(c("OG","pungens","quiescens","umbonatus") %in% names(ortho)))

pheno <- read_csv(phenotypes_csv, show_col_types = FALSE)

ogs_keep <- read_csv(conserved_csv, show_col_types = FALSE) %>%
  transmute(OG = as.character(OG)) %>%
  distinct() %>%
  pull(OG)

# gene->OG mapping table (only 3 mapping species)
map_all <- bind_rows(
  make_map(ortho, "pungens",   "pungens"),
  make_map(ortho, "quiescens", "quiescens"),
  make_map(ortho, "umbonatus", "umbonatus")
)

# ----------------------------
# Build updated long table
# ----------------------------
long_pun <- agg_counts_by_og_with_pheno(
  dds = dds_pungens,
  map_df = map_all,
  map_species = "pungens",
  pheno_df = pheno,
  pheno_id_col = "Admera_ID",      # <-- switch to "CustomerID" if needed
  pheno_species_col = "Species",
  og_keep = ogs_keep,
  normalized = FALSE
)

long_qui <- agg_counts_by_og_with_pheno(
  dds = dds_quiescens,
  map_df = map_all,
  map_species = "quiescens",
  pheno_df = pheno,
  pheno_id_col = "Admera_ID",
  pheno_species_col = "Species",
  og_keep = ogs_keep,
  normalized = FALSE
)

long_umb <- agg_counts_by_og_with_pheno(
  dds = dds_umbonatus,
  map_df = map_all,
  map_species = "umbonatus",
  pheno_df = pheno,
  pheno_id_col = "Admera_ID",
  pheno_species_col = "Species",
  og_keep = ogs_keep,
  normalized = FALSE
)
sample_orthogroup_counts_long <- bind_rows(long_pun, long_qui, long_umb)
write_csv(sample_orthogroup_counts_long, "R/sample_orthogroup_counts_long.csv")



```

```{r, PCA with Orthogroups}
# Read the long table: columns should include species, sample, OG, count
df <- read_csv("R/sample_orthogroup_counts_long.csv", show_col_types = FALSE)

# OPTIONAL but strongly recommended:
# make sample IDs globally unique across species to avoid name collisions
df <- df %>%
  mutate(sample_id = paste(species, sample, sep="::"))

# Build sample × OG matrix (wide)
mat_df <- df %>%
  select(sample_id, OG, count) %>%
  pivot_wider(names_from = OG, values_from = count, values_fill = 0)

mat <- as.matrix(mat_df[,-1])
rownames(mat) <- mat_df$sample_id

# Transform counts (log1p is a good default)
mat_log <- log1p(mat)

# Filter OGs with (near) zero variance across samples (they add noise)
v <- apply(mat_log, 2, var)
mat_log <- mat_log[, v > 0, drop=FALSE]

# PCA (center+scale so OGs contribute comparably)
pca <- prcomp(mat_log, center = TRUE, scale. = TRUE)

# Make a plot-ready dataframe
pca_df <- as.data.frame(pca$x[, 1:3]) %>%
  tibble::rownames_to_column("sample_id") %>%
  separate(sample_id, into=c("species","sample"), sep="::", remove=FALSE)

# (Optional) add metadata columns if your long df contained colData columns:
meta <- df %>%
  distinct(species, sample)  # add other colData columns here if present (e.g. wp, batch)
pca_df <- left_join(pca_df, meta, by=c("species","sample"))

# Percent variance explained
pct <- (pca$sdev^2) / sum(pca$sdev^2)

ggplot(pca_df, aes(PC1, PC2, color = species)) +
  geom_point(size=3, alpha=0.85) +
  labs(
    x = sprintf("PC1 (%.1f%%)", 100*pct[1]),
    y = sprintf("PC2 (%.1f%%)", 100*pct[2])
  ) +
  theme_classic()

df %>% summarise(n_OG = n_distinct(OG))
df %>% distinct(species, OG) %>% count(species)
```

```{r, OG Analysis}
############################ ANALYSIS #################################################
#top OG groups diferentially epxressed to WP
sig_thresh <- 0.05
top_n_og   <- 50

og_top_wp <- og_wide_annot %>%
  mutate(
    min_padj_wp = pmin(padj.pungens, padj.quiescens, padj.umbonatus, na.rm = TRUE),
    n_sig_wp    = (padj.pungens  < sig_thresh) +
                  (padj.quiescens< sig_thresh) +
                  (padj.umbonatus< sig_thresh),
    max_abs_lfc_wp = pmax(
      abs(log2FoldChange.pungens),
      abs(log2FoldChange.quiescens),
      abs(log2FoldChange.umbonatus),
      na.rm = TRUE
    )
  ) %>%
  arrange(min_padj_wp, desc(n_sig_wp), desc(max_abs_lfc_wp)) %>%
  slice_head(n = top_n_og)

og_top_wp %>%
  select(OG, min_padj_wp, n_sig_wp, max_abs_lfc_wp,
         starts_with("pungens_"), starts_with("quiescens_"), starts_with("umbonatus_"))
og_top_wp_all3 <- og_top_wp %>% filter(OG %in% ogs_in_all3)

top_n_og <- 50

# og_top_wp already sorted by min_padj_wp etc.
top_ogs <- og_top_wp %>%
  slice_head(n = top_n_og) %>%
  pull(OG)
lfc_mat <- og_wide %>%
  filter(OG %in% top_ogs) %>%
  # keep OG order consistent with top_ogs (optional but nice)
  arrange(match(OG, top_ogs)) %>%
  select(
    OG,
    log2FoldChange.pungens,
    log2FoldChange.quiescens,
    log2FoldChange.umbonatus
  ) %>%
  column_to_rownames("OG") %>%
  as.matrix()

# optional: nicer column names in the heatmap
colnames(lfc_mat) <- c("pungens", "quiescens", "umbonatus")

library(pheatmap)
library(RColorBrewer)
breaks <- seq(-2, 2, length.out = 201)
my_colors <- colorRampPalette(rev(brewer.pal(11, "RdBu")))(200)
max_lfc <- quantile(abs(lfc_mat), 0.95, na.rm = TRUE)  # ignore extreme 1%
breaks  <- seq(-max_lfc, max_lfc, length.out = 201)

pheatmap(
  lfc_mat,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  scale = "none",                 # true log2FC (no row scaling)
  color = my_colors,
  breaks = breaks,
  main  = "Top orthogroups (log2FC, water potential)",
  border_color = NA,
  show_rownames = TRUE,          # cleaner when many OGs
  fontsize_row = 6,
  fontsize_col = 12,
  angle_col = 45,                 # angled species labels
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "complete"
)

```

```{r, Summary stats}

og_df <- ortho_annotated %>%
  select(OG, pungens, quiescens, umbonatus) %>%
  mutate(
    has_pun = !is.na(pungens)   & str_trim(pungens)   != "",
    has_qui = !is.na(quiescens) & str_trim(quiescens) != "",
    has_umb = !is.na(umbonatus) & str_trim(umbonatus) != "",
    n_species = has_pun + has_qui + has_umb
  )

# ---- simple counts ----
n_all3     <- og_df %>% filter(n_species == 3) %>% nrow()                      # present in all 3
n_unique_p <- og_df %>% filter(n_species == 1, has_pun) %>% nrow()             # unique to pungens
n_unique_q <- og_df %>% filter(n_species == 1, has_qui) %>% nrow()             # unique to quiescens
n_unique_u <- og_df %>% filter(n_species == 1, has_umb) %>% nrow()             # unique to umbonatus

n_pq_only  <- og_df %>% filter(n_species == 2, has_pun, has_qui) %>% nrow()    # only pungens & quiescens
n_pu_only  <- og_df %>% filter(n_species == 2, has_pun, has_umb) %>% nrow()    # only pungens & umbonatus
n_qu_only  <- og_df %>% filter(n_species == 2, has_qui, has_umb) %>% nrow()    # only quiescens & umbonatus

# Optional: a neat summary table
summary_tbl <- tibble::tibble(
  category = c("All three", 
               "Unique: pungens", "Unique: quiescens", "Unique: umbonatus",
               "Shared only: pungens+quiescens", "Shared only: pungens+umbonatus", "Shared only: quiescens+umbonatus"),
  count    = c(n_all3, n_unique_p, n_unique_q, n_unique_u, n_pq_only, n_pu_only, n_qu_only)
)

summary_tbl

ogs_all3      <- og_df %>% filter(n_species == 3) %>% pull(OG)
ogs_unique_p  <- og_df %>% filter(n_species == 1, has_pun) %>% pull(OG)
ogs_unique_q  <- og_df %>% filter(n_species == 1, has_qui) %>% pull(OG)
ogs_unique_u  <- og_df %>% filter(n_species == 1, has_umb) %>% pull(OG)
ogs_pq_only   <- og_df %>% filter(n_species == 2, has_pun, has_qui) %>% pull(OG)
ogs_pu_only   <- og_df %>% filter(n_species == 2, has_pun, has_umb) %>% pull(OG)
ogs_qu_only   <- og_df %>% filter(n_species == 2, has_qui, has_umb) %>% pull(OG)

install.packages("VennDiagram")
library(VennDiagram)
library(grid)

# --- your summary counts ---
summary_tbl <- data.frame(
  category = c("All three",
               "Unique: pungens", "Unique: quiescens", "Unique: umbonatus",
               "pungens+quiescens", "pungens+umbonatus", "quiescens+umbonatus"),
  n = c(7269, 153, 68, 403, 383, 783, 1011)
)

# unpack for convenience
n123 <- summary_tbl$n[summary_tbl$category == "All three"]
u_p  <- summary_tbl$n[summary_tbl$category == "Unique: pungens"]
u_q  <- summary_tbl$n[summary_tbl$category == "Unique: quiescens"]
u_u  <- summary_tbl$n[summary_tbl$category == "Unique: umbonatus"]
pq_o <- summary_tbl$n[summary_tbl$category == "pungens+quiescens"]
pu_o <- summary_tbl$n[summary_tbl$category == "pungens+umbonatus"]
qu_o <- summary_tbl$n[summary_tbl$category == "quiescens+umbonatus"]

# VennDiagram::draw.triple.venn needs totals and pairwise intersections (including the triple)
area1 <- u_p + pq_o + pu_o + n123    # pungens total
area2 <- u_q + pq_o + qu_o + n123    # quiescens total
area3 <- u_u + pu_o + qu_o + n123    # umbonatus total
n12   <- pq_o + n123                  # pun ∩ qui
n13   <- pu_o + n123                  # pun ∩ umb
n23   <- qu_o + n123                  # qui ∩ umb

# quick sanity check (optional)
stopifnot(area1 > 0, area2 > 0, area3 > 0)

# draw to screen
grid.newpage()
venn.plot <- draw.triple.venn(
  area1 = area1, area2 = area2, area3 = area3,
  n12 = n12, n23 = n23, n13 = n13, n123 = n123,
  category = c("pungens", "quiescens", "umbonatus"),
  fill = c("#A6CEE3", "#B2DF8A", "#FB9A99"),
  alpha = 0.6, lty = "blank", cex = 1.2, cat.cex = 1.2
)

# save to file (optional)
png("/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/output_figures/orthogroups_venn_counts.png", width = 1200, height = 900, res = 200)
grid.newpage()
draw.triple.venn(
  area1 = area1, area2 = area2, area3 = area3,
  n12 = n12, n23 = n23, n13 = n13, n123 = n123,
  category = c("pungens", "quiescens", "umbonatus"),
  fill = c("#A6CEE3", "#B2DF8A", "#FB9A99"),
  alpha = 0.6, lty = "blank", cex = 1.2, cat.cex = 1.2
)
dev.off()




########UPREGULATION AND DOWNREGULATION DIAGRAMS ################################
library(dplyr)

sig_thresh <- 0.05

# clean out obvious NAs
res_gene_top_clean <- res_gene_top %>%
  filter(!is.na(OG),
         !is.na(padj),
         !is.na(log2FoldChange))

# helper function: given a species name, return OGs that are sig up/down
get_up_down_ogs <- function(df, species_name, padj_cutoff = 0.05) {
  df_sp <- df %>% filter(species == species_name)

  ogs_up <- df_sp %>%
    filter(padj < padj_cutoff, log2FoldChange > 0) %>%
    pull(OG) %>%
    unique()

  ogs_down <- df_sp %>%
    filter(padj < padj_cutoff, log2FoldChange < 0) %>%
    pull(OG) %>%
    unique()

  list(up = ogs_up, down = ogs_down)
}

pun_sets <- get_up_down_ogs(res_gene_top_clean, "pungens",   sig_thresh)
qui_sets <- get_up_down_ogs(res_gene_top_clean, "quiescens", sig_thresh)
umb_sets <- get_up_down_ogs(res_gene_top_clean, "umbonatus", sig_thresh)

pun_up  <- pun_sets$up
qui_up  <- qui_sets$up
umb_up  <- umb_sets$up

pun_down <- pun_sets$down
qui_down <- qui_sets$down
umb_down <- umb_sets$down

a1 <- length(pun_up)
a2 <- length(qui_up)
a3 <- length(umb_up)

# pairwise intersections
n12 <- length(intersect(pun_up, qui_up))
n13 <- length(intersect(pun_up, umb_up))
n23 <- length(intersect(qui_up, umb_up))

# triple intersection
n123 <- length(Reduce(intersect, list(pun_up, qui_up, umb_up)))

# sanity check
stopifnot(a1 >= n12, a2 >= n12, a3 >= n13, a3 >= n23)
####UPREGULATED #########
grid.newpage()
draw.triple.venn(
  area1 = a1, area2 = a2, area3 = a3,
  n12 = n12, n23 = n23, n13 = n13, n123 = n123,
  category = c("pungens", "quiescens", "umbonatus"),
  fill = c("#88CCEE", "#44AA99", "#EE6677"),
  alpha = 0.7,
  lwd = 0.8,
  col = "grey30",
  cex = 1.3,
  fontface = "bold",
  cat.cex = 1.3,
  cat.fontface = "bold",
  main = "Upregulated orthogroups (high WP vs low WP)"
)
##### DOWN REGULATED #######
# areas
b1 <- length(pun_down)
b2 <- length(qui_down)
b3 <- length(umb_down)

# pairwise intersections
m12 <- length(intersect(pun_down, qui_down))
m13 <- length(intersect(pun_down, umb_down))
m23 <- length(intersect(qui_down, umb_down))

# triple intersection
m123 <- length(Reduce(intersect, list(pun_down, qui_down, umb_down)))

png("Venn_downregulated_orthogroups_wp.png", width = 1800, height = 1400, res = 300)
grid.newpage()
draw.triple.venn(
  area1 = b1, area2 = b2, area3 = b3,
  n12 = m12, n23 = m23, n13 = m13, n123 = m123,
  category = c("pungens", "quiescens", "umbonatus"),
  fill = c("#88CCEE", "#44AA99", "#EE6677"),
  alpha = 0.7,
  lwd = 0.8,
  col = "grey30",
  cex = 1.3,
  fontface = "bold",
  cat.cex = 1.3,
  cat.fontface = "bold",
  main = "Downregulated orthogroups (high WP vs low WP)"
)

```

```{r, extras}
ortho_annot <- read.csv("/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/R/ortho_annotated.csv")
og_conserved <- read.csv("/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/R/Orthogroups_conserved3species.csv")
sample_phenotypes_df <- read.csv("/Users/jyeam/Documents/Projects/2024_Stress_Tolerance/R/sample_phenotypes_df.csv")


# Re-use your ID normalizer
norm_id <- function(x){
  x %>%
    as.character() %>%
    str_trim() %>%
    str_replace("\\.\\d+$","") %>%        # drop version suffix: .1, .2
    str_replace("-RA$","") %>%            # drop isoform tags
    str_replace("-T\\d+$","")             # drop transcript suffixes
}
make_map <- function(ortho, species_col, species_name) {
  ortho %>%
    select(OG, all_of(species_col)) %>%
    mutate(across(all_of(species_col), as.character)) %>%
    mutate(!!species_col := na_if(.data[[species_col]], "")) %>%
    separate_rows(!!sym(species_col), sep = ",\\s*") %>%
    filter(!is.na(.data[[species_col]])) %>%
    rename(GENEID = !!sym(species_col)) %>%
    mutate(
      GENEID = norm_id(GENEID),
      species = species_name
    )
}
map_pun <- make_map(ortho_annot, "pungens",   "pungens")
map_qui <- make_map(ortho_annot, "quiescens", "quiescens")
map_umb <- make_map(ortho_annot, "umbonatus", "umbonatus")

map_all <- bind_rows(map_pun, map_qui, map_umb)
# map_all: OG, GENEID, species

# Create count matrix for pungens, quiescens, and umbo and then concatenate them all into one
counts_pun <- counts(dds_pungens, normalized = FALSE) %>% # 1) Extract raw counts and normalize gene IDs
  as.data.frame() %>%
  rownames_to_column("GENEID") %>%
  mutate(GENEID = norm_id(GENEID))
pun_with_og <- counts_pun %>% # 2) Join to OG mapping
  inner_join(map_pun2 %>% select(OG, GENEID), by = "GENEID")
counts_pun_og_df <- pun_with_og %>% # 3) Sum counts per orthogroup
  group_by(OG) %>%
  summarise(across(where(is.numeric), sum), .groups = "drop")
counts_pun_og <- counts_pun_og_df %>% # 4) Make a matrix with OG as rownames
  column_to_rownames("OG") %>%
  as.matrix()

# Quiescens
counts_qui <- counts(dds_quiescens, normalized = FALSE) %>%
  as.data.frame() %>%
  rownames_to_column("GENEID") %>%
  mutate(GENEID = norm_id(GENEID))
qui_with_og <- counts_qui %>%
  inner_join(map_qui2 %>% select(OG, GENEID), by = "GENEID")
counts_qui_og_df <- qui_with_og %>%
  group_by(OG) %>%
  summarise(across(where(is.numeric), sum), .groups = "drop")
counts_qui_og <- counts_qui_og_df %>%
  column_to_rownames("OG") %>%
  as.matrix()

# Umbonatus
counts_umb <- counts(dds_umbonatus, normalized = FALSE) %>%
  as.data.frame() %>%
  rownames_to_column("GENEID") %>%
  mutate(GENEID = norm_id(GENEID))
umb_with_og <- counts_umb %>%
  inner_join(map_umb2 %>% select(OG, GENEID), by = "GENEID")
counts_umb_og_df <- umb_with_og %>%
  group_by(OG) %>%
  summarise(across(where(is.numeric), sum), .groups = "drop")
counts_umb_og <- counts_umb_og_df %>%
  column_to_rownames("OG") %>%
  as.matrix()

# Option: keep all OGs that appear in at least one species
all_ogs <- sort(unique(c(
  rownames(counts_pun_og),
  rownames(counts_qui_og),
  rownames(counts_umb_og)
)))

# Function to pad a matrix with missing OGs (fill 0s)
pad_ogs <- function(mat, ogs) {
  missing_ogs <- setdiff(ogs, rownames(mat))
  if (length(missing_ogs) > 0) {
    pad_mat <- matrix(0L, nrow = length(missing_ogs), ncol = ncol(mat),
                      dimnames = list(missing_ogs, colnames(mat)))
    mat <- rbind(mat, pad_mat)
  }
  mat[ogs, , drop = FALSE]  # order rows by all_ogs
}

counts_pun_og2 <- pad_ogs(counts_pun_og, all_ogs)
counts_qui_og2 <- pad_ogs(counts_qui_og, all_ogs)
counts_umb_og2 <- pad_ogs(counts_umb_og, all_ogs)

# Now cbind columns
counts_og <- cbind(counts_pun_og2, counts_qui_og2, counts_umb_og2)

################################################################################

coldata <- sample_phenotypes_df %>%
  mutate(
    # harmonize species labels to match your 3 species
    species = case_when(
      str_detect(Species, "pungens")   ~ "pungens",
      Species == "quiescens"          ~ "quiescens",
      Species == "umbonatus"          ~ "umbonatus",
      TRUE                            ~ Species
    ),
    # WP: make factor. Put "low" first so contrasts are high vs low
    WP = factor(WP, levels = c("low", "high")),
    # growth: numeric column for growth rate / biomass
    growth = as.numeric(Dried.Weight.Week),
    # optional: add batch/temperature if you want to adjust for them
    batch = factor(Batch) %||% factor(1),
    temp  = factor(Temperature)
  ) %>%
  select(Admera_ID, species, WP, growth, batch, temp) %>%
  column_to_rownames("Admera_ID")
stopifnot(all(colnames(counts_og) %in% rownames(coldata)))
coldata <- coldata[colnames(counts_og), ]


library(DESeq2)
#Create Deseq2 Object
coldata$growth <- scale(coldata$growth, center = TRUE, scale = TRUE)
dds_og <- DESeqDataSetFromMatrix(
  countData = counts_og,
  colData   = coldata,
  design    = ~ species + WP + growth  # will update for interactions below
)

#G×E for water potential: species × WP
dds_gxe_wp <- dds_og
design(dds_gxe_wp) <- ~ species + WP + species:WP

dds_gxe_wp <- DESeq(dds_gxe_wp, test = "LRT",
                    reduced = ~ species + WP)

res_gxe_wp <- results(dds_gxe_wp)
res_gxe_wp_df <- as.data.frame(res_gxe_wp) %>%
  rownames_to_column("OG")

sig_gxe_wp <- res_gxe_wp_df %>%
  filter(!is.na(padj), padj < 0.05)

#G×E for growth: species × growth
dds_gxe_growth <- dds_og
design(dds_gxe_growth) <- ~ species + WP + growth + species:growth

dds_gxe_growth <- DESeq(dds_gxe_growth, test = "LRT",
                        reduced = ~ species + WP + growth)

res_gxe_growth <- results(dds_gxe_growth)
res_gxe_growth_df <- as.data.frame(res_gxe_growth) %>%
  rownames_to_column("OG")

sig_gxe_growth <- res_gxe_growth_df %>%
  filter(!is.na(padj), padj < 0.05)

#G×E for growth: species × growth
dds_gxe_growth <- dds_og
design(dds_gxe_growth) <- ~ species + WP + growth + species:growth

dds_gxe_growth <- DESeq(dds_gxe_growth, test = "LRT",
                        reduced = ~ species + WP + growth)

res_gxe_growth <- results(dds_gxe_growth)
res_gxe_growth_df <- as.data.frame(res_gxe_growth) %>%
  rownames_to_column("OG")

sig_gxe_growth <- res_gxe_growth_df %>%
  filter(!is.na(padj), padj < 0.05)

#Both
dds_both <- dds_og
design(dds_both) <- ~ species + WP + growth + species:WP + species:growth

dds_both <- DESeq(dds_both, test = "LRT",
                  reduced = ~ species + WP + growth)

res_gxe_both <- results(dds_both)
res_gxe_both_df <- as.data.frame(res_gxe_both) %>%
  rownames_to_column("OG")

#WP G×E only (control for growth G×E):
dds_wp_only <- dds_both
dds_wp_only <- DESeq(dds_wp_only, test = "LRT",
                     reduced = ~ species + WP + growth + species:growth)

res_gxe_wp_only <- as.data.frame(results(dds_wp_only)) %>%
  rownames_to_column("OG")

#Growth G×E only:
dds_growth_only <- dds_both
dds_growth_only <- DESeq(dds_growth_only, test = "LRT",
                         reduced = ~ species + WP + growth + species:WP)
res_gxe_growth_only <- as.data.frame(results(dds_growth_only)) %>%
  rownames_to_column("OG")
#WP (categorical high vs low)
#Growth (continuous)
dds_growth_wald <- dds_og
design(dds_growth_wald) <- ~ species + WP + growth + species:growth
dds_growth_wald <- DESeq(dds_growth_wald)
resultsNames(dds_growth_wald)

```


```{r, GxE plots}
gxe_wp_annot <- res_gxe_wp_df %>%
  left_join(ortho_annotated, by = "OG")

# Top WP G×E hits
gxe_wp_top <- gxe_wp_annot %>%
  filter(!is.na(padj)) %>%
  arrange(padj) %>%
  slice_head(n = 50)

gxe_wp_top %>% select(OG, stat, pvalue, padj) %>% print(n = 10)

res_gxe_growth_only <- as.data.frame(results(dds_growth_only)) %>%
  rownames_to_column("OG")
gxe_growth_annot <- res_gxe_growth_df %>%
  left_join(ortho_annotated, by = "OG")

gxe_growth_top <- gxe_growth_annot %>%
  filter(!is.na(padj)) %>%
  arrange(padj) %>%
  slice_head(n = 50)

gxe_growth_top %>% select(OG, stat, pvalue, padj) %>% print(n = 10)

vsd_wp <- vst(dds_gxe_wp, blind = FALSE)
vsd_mat_wp <- assay(vsd_wp)

plot_og_wp <- function(og_id, vsd_mat, coldata){
  stopifnot(og_id %in% rownames(vsd_mat))
  
  plot_df <- data.frame(
    expr   = vsd_mat[og_id, ],
    sample = colnames(vsd_mat)
  ) %>%
    left_join(as.data.frame(coldata) %>%
                rownames_to_column("sample"),
              by = "sample")
  
  ggplot(plot_df, aes(x = WP, y = expr, color = species)) +
    geom_jitter(width = 0.1, size = 2) +
    stat_summary(fun = mean, geom = "line", aes(group = species),
                 position = position_dodge(width = 0.2)) +
    labs(
      title = paste("G×E WP for", og_id),
      y = "VST expression"
    ) +
    theme_bw()
}

top_og_wp <- gxe_wp_top$OG[4]
top_og_wp
#Plot the top WP G×E orthogroup
plot_og_wp(top_og_wp, vsd_mat_wp, coldata)

#Plot top Growth GxE orthogroup
vsd_growth <- vst(dds_gxe_growth, blind = FALSE)
vsd_mat_growth <- assay(vsd_growth)

plot_og_growth <- function(og_id, vsd_mat, coldata){
  stopifnot(og_id %in% rownames(vsd_mat))
  
  plot_df <- data.frame(
    expr   = vsd_mat[og_id, ],
    sample = colnames(vsd_mat)
  ) %>%
    left_join(as.data.frame(coldata) %>%
                rownames_to_column("sample"),
              by = "sample")
  
  ggplot(plot_df, aes(x = growth, y = expr, color = species)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = FALSE) +
    labs(
      title = paste("G×E growth for", og_id),
      x = "Growth",
      y = "VST expression"
    ) +
    theme_bw()
}

top_og_growth <- gxe_growth_top$OG[1]
top_og_growth

plot_og_growth(top_og_growth, vsd_mat_growth, coldata)


library(readr)
og_conserved_gxe_wp <- og_conserved %>%
  left_join(res_gxe_wp_df %>% select(OG, stat, pvalue, padj),
            by = "OG",
            suffix = c("", ".gxe_wp"))

og_conserved_gxe_growth <- og_conserved %>%
  left_join(res_gxe_growth_df %>% select(OG, stat, pvalue, padj),
            by = "OG",
            suffix = c("", ".gxe_growth"))

og_conserved_gxe_wp %>%
  count(concordance, cut(padj, c(0, 0.05, 0.1, 1)),
        name = "n_OGs")

# Use the LRT statistic as ranking
ranks_wp <- res_gxe_wp_df$stat
names(ranks_wp) <- res_gxe_wp_df$OG
ranks_wp <- sort(ranks_wp, decreasing = TRUE)

```

```{r, GSEA}
og_go_long <- ortho_annotated %>%
  select(OG,
         pungens_GO.Terms,
         quiescens_GO.Terms,
         umbonatus_GO.Terms) %>%
  pivot_longer(
    cols      = -OG,
    names_to  = "species_go_col",
    values_to = "GO_terms"
  ) %>%
  # drop missing / empty
  filter(!is.na(GO_terms), GO_terms != "") %>%
  # split multiple GO terms (assuming ; or , separators)
  mutate(GO_terms = str_split(GO_terms, pattern = "[;,]\\s*")) %>%
  tidyr::unnest(GO_terms) %>%
  mutate(GO_terms = str_trim(GO_terms)) %>%
  filter(GO_terms != "")

# Quick sanity check
og_go_long %>% head()
length(unique(og_go_long$OG))
length(unique(og_go_long$GO_terms))

go2og <- og_go_long %>%
  distinct(GO_terms, OG) %>%   # remove duplicates
  group_by(GO_terms) %>%
  summarise(ogs = list(unique(OG)), .groups = "drop")

# named list: each element is a character vector of OGs
pathways_og <- setNames(go2og$ogs, go2og$GO_terms)

# sanity: how big are the GO sets?
summary(lengths(pathways_og))

library(tibble)

ranks_wp_vec <- res_gxe_wp_df %>%
  filter(!is.na(stat)) %>%
  transmute(OG, stat)

ranks_wp_vec <- setNames(ranks_wp_vec$stat, ranks_wp_vec$OG)
ranks_wp_vec <- sort(ranks_wp_vec, decreasing = TRUE)

ranks_growth_vec <- res_gxe_growth_df %>%
  filter(!is.na(stat)) %>%
  transmute(OG, stat)

ranks_growth_vec <- setNames(ranks_growth_vec$stat, ranks_growth_vec$OG)
ranks_growth_vec <- sort(ranks_growth_vec, decreasing = TRUE)

library(fgsea)

set.seed(123)

# WP G×E
fgsea_wp <- fgsea(
  pathways = pathways_og,
  stats    = ranks_wp_vec,
  minSize  = 10,    # tune as you like
  maxSize  = 500
)

fgsea_wp_res <- fgsea_wp %>%
  arrange(padj)

head(fgsea_wp_res[, c("pathway", "NES", "pval", "padj")])
# Growth G×E
fgsea_growth <- fgsea(
  pathways = pathways_og,
  stats    = ranks_growth_vec,
  minSize  = 10,
  maxSize  = 500
)

fgsea_growth_res <- fgsea_growth %>%
  arrange(padj)

head(fgsea_growth_res[, c("pathway", "NES", "pval", "padj")])

library(clusterProfiler)

term2gene <- og_go_long %>%
  distinct(GO_terms, OG) %>%
  rename(term = GO_terms, gene = OG)

term2gene <- term2gene %>%
  mutate(
    term = term %>%
      str_replace("^.*-\\s*", "") %>%            # remove everything before/including " - "
      str_replace("\\[.*\\]$", "") %>%           # remove [Evidence ...]
      str_trim()                                 # trim whitespace
  )
# If you don't have GO descriptions handy, just use GO IDs as names
term2name <- data.frame(
  term = unique(term2gene$pathway),
  name = unique(term2gene$pathway)
)

gsea_wp_cp <- GSEA(
  geneList    = ranks_wp_vec,    # named numeric vector (OGs)
  TERM2GENE   = term2gene,
  TERM2NAME   = term2name,
  pvalueCutoff = 1
)

gsea_wp_cp_res <- as.data.frame(gsea_wp_cp)
head(gsea_wp_cp_res[, c("ID", "NES", "p.adjust")])

gsea_growth_cp <- GSEA(
  geneList    = ranks_growth_vec,
  TERM2GENE   = term2gene,
  TERM2NAME   = term2name,
  pvalueCutoff = 1
)

gsea_growth_cp_res <- as.data.frame(gsea_growth_cp)

# what fraction of OGs in your ranks have at least one GO term?
mean(names(ranks_wp_vec) %in% og_go_long$OG)

# are your OG names in ranks compatible with term2gene?
mean(names(ranks_wp_vec) %in% term2gene$gene)

fgsea_wp_res <- fgsea_wp %>% arrange(padj)
library(dplyr)
library(ggplot2)

top_n <- 20

fgsea_wp_top <- fgsea_wp_res %>%
  filter(padj < 0.1) %>%          # adjust threshold if you want
  slice_max(order_by = abs(NES), n = top_n) %>% 
  mutate(
    direction = ifelse(NES > 0, "positive", "negative"),
    pathway   = factor(pathway, levels = pathway[order(NES)])  # for ordered y-axis
  )

top_pathway <- fgsea_wp_res$pathway[1]
top_pathway

fgsea::plotEnrichment(
  pathway = pathways_og[[top_pathway]],  # the OGs in that GO term
  stats   = ranks_wp_vec
) + ggtitle(top_pathway)

plot_fgsea_pathway <- function(pathway_id, pathways, ranks){
  fgsea::plotEnrichment(
    pathway = pathways[[pathway_id]],
    stats   = ranks
  ) + ggtitle(pathway_id)
}

# usage:
plot_fgsea_pathway(fgsea_wp_top$pathway[1], pathways_og, ranks_wp_vec)
gsea_wp_cp

dotplot(gsea_wp_cp, showCategory = 20, split = ".sign") +
  facet_grid(. ~ .sign) +
  ggtitle("GO GSEA – WP G×E")

dotplot(gsea_wp_cp, showCategory = 20, split = ".sign") +
  facet_grid(. ~ .sign) +
  ggtitle("GO GSEA – WP G×E") +
  theme(
    axis.text.y = element_text(size = 8) 
  )
gsea_df <- as.data.frame(gsea_wp_cp)

top20_tbl <- gsea_df %>%
  arrange(p.adjust) %>%
  slice_head(n = 20)


gsea_wp_cp_top20 <- gsea_wp_cp
gsea_wp_cp_top20@result <- top20_tbl
## 4. Now plot the dotplot using the gseaResult subset
dotplot(gsea_wp_cp_top20, showCategory = 20, split = ".sign") +
  facet_grid(. ~ .sign) +
  ggtitle("Top 20 GO Terms – WP G×E (GSEA)")

gsea_df <- as.data.frame(gsea_wp_cp)

gsea_wp_top20_df <- gsea_df %>%
  arrange(p.adjust) %>%           # top 20 by adj p (change if you want NES-based)
  slice_head(n = 20) %>%
  mutate(
    sign = ifelse(NES > 0, "positive", "negative"),
    # wrap long descriptions for readability
    Description = str_wrap(Description, width = 45),
    # order y-axis by NES (or p.adjust if you prefer)
    Description = factor(Description, levels = rev(Description))
  )

library(ggplot2)

ggplot(gsea_wp_top20_df,
       aes(x = NES, y = Description,
           size = setSize,
           color = -log10(p.adjust))) +
  geom_point() +
  facet_grid(. ~ sign) +
  scale_color_viridis_c() +
  labs(
    title = "Top 20 GO terms – WP G×E (GSEA)",
    x     = "NES",
    y     = NULL,
    size  = "OGs in GO term",
    color = "-log10(adj p)"
  ) +
  theme_bw(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 10)
  )

library(ggplot2)

ggplot(gsea_wp_top20_df,
       aes(x = NES,
           y = Description,
           size = setSize,
           fill = -log10(p.adjust))) +   # fill instead of color
  geom_point(shape = 21, color = "black", stroke = 0.3) +  # border
  facet_grid(. ~ sign) +
  
  # --- EXACT dotplot color scale ---
  scale_fill_gradientn(
    colors = c("#B40426", "#7F3B8D", "#3B528B", "#1F78B4"),
    name = "-log10(p.adjust)"
  ) +
  
  # --- replicate enrichplot dot sizes ---
  scale_size(range = c(3, 12)) +

  labs(
    title = "Top 20 GO terms – WP G×E (GSEA)",
    x = "NES",
    y = NULL,
    size = "OG Count"
  ) +
  
  theme_bw(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 9),
    strip.text = element_text(size = 12, face = "bold"),
    legend.key = element_rect(fill = "white", color = "white")
  )
```
